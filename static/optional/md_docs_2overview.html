<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>beman::optional: Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
 <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
 <script type="text/javascript">
     DoxygenAwesomeDarkModeToggle.init()
 </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="beman-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">beman::optional
   </div>
   <div id="projectbrief">Optional Values and References</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_docs_2overview.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Overview </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md1"></a>
Motivation</h1>
<p>Other than the standard library's implementation of optional, optionals holding references are common. The desire for such a feature is well understood, and many optional types in commonly used libraries provide it, with the semantics proposed here. One standard library implementation already provides an implementation of <span class="tt">std::optional&lt;T&amp;&gt;</span> but disables its use, because the standard forbids it.</p>
<p>The research in JeanHeyd Meneide's <em>References for Standard Library Vocabulary Types - an optional case study.</em> P1683R0 shows conclusively that rebind semantics are the only safe semantic as assign through on engaged is too bug-prone. Implementations that attempt assign-through are abandoned. The standard library should follow existing practice and supply an <span class="tt">optional&lt;T&amp;&gt;</span> that rebinds on assignment.</p>
<p>Additional background reading on <span class="tt">optional&lt;T&amp;&gt;</span> can be found in JeanHeyd Meneide's article <em>To Bind and Loose a Reference</em> REFBIND.</p>
<p>In freestanding environments or for safety-critical libraries, an optional type over references is important to implement containers, that otherwise as the standard library either would cause undefined behavior when accessing an non-available element, throw an exception, or silently create the element. Returning a plain pointer for such an optional reference, as the core guidelines suggest, is a non-type-safe solution and doesn't protect in any way from accessing an non-existing element by a <span class="tt">nullptr</span> de-reference. In addition, the monadic APIs of <span class="tt">std::optional</span> makes is especially attractive by streamlining client code receiving such an optional reference, in contrast to a pointer that requires an explicit nullptr check and de-reference.</p>
<p>There is a principled reason not to provide a partial specialization over <span class="tt">T&amp;</span> as the semantics are in some ways subtly different than the primary template. Assignment may have side-effects not present in the primary, which has pure value semantics. However, I argue this is misleading, as reference semantics often has side-effects. The proposed semantic is similar to what an <span class="tt">optional&lt;std::reference_wrapper&lt;T&gt;&gt;</span> provides, with much greater usability.</p>
<p>There are well motivated suggestions that perhaps instead of an <span class="tt">optional&lt;T&amp;&gt;</span> there should be an <span class="tt">optional_ref&lt;T&gt;</span> that is an independent primary template. This proposal rejects that, because we need a policy over all sum types as to how reference semantics should work, as optional is a variant over T and monostate. That the library sum type can not express the same range of types as the product type, tuple, is an increasing problem as we add more types logically equivalent to a variant. The template types <span class="tt">optional</span> and <span class="tt">expected</span> should behave as extensions of <span class="tt">variant&lt;T, monostate&gt;</span> and <span class="tt">variant&lt;T, E&gt;</span>, or we lose the ability to reason about generic types.</p>
<p>That we can't guarantee from <span class="tt">std::tuple&lt;Args...&gt;</span> (product type) that <span class="tt">std::variant&lt;Args...&gt;</span> (sum type) is valid, is a problem, and one that reflection can't solve. A language sum type could, but we need agreement on the semantics.</p>
<p>The semantics of a variant with a reference are as if it holds the address of the referent when referring to that referent. All other semantics are worse. Not being able to express a variant&lt;T&amp;&gt; is inconsistent, hostile, and strictly worse than disallowing it.</p>
<p>Thus, we expect future papers to propose <span class="tt">std::expected&lt;T&amp;,E&gt;</span> and <span class="tt">std::variant</span> with the ability to hold references. The latter can be used as an iteration type over <span class="tt">std::tuple</span> elements.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md2"></a>
Design</h1>
<p>The design is straightforward. The <span class="tt">optional&lt;T&amp;&gt;</span> holds a pointer to the underlying object of type <span class="tt">T</span>, or <span class="tt">nullptr</span> if the optional is disengaged. The implementation is simple, especially with C++20 and up techniques, using concept constraints. As the held pointer is a primitive regular type with reference semantics, many operations can be defaulted and are <span class="tt">noexcept</span> by nature. See Downey_smd_optional_optional_T and rawgithu58:online. The <span class="tt">optional&lt;T&amp;&gt;</span> implementation is less than 200 lines of code, much of it the monadic functions with identical textual implementations with different signatures and different overloads being called.</p>
<p>In place construction is not supported as it would just be a way of providing immediate life-time issues.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md3"></a>
Relational Operations</h2>
<p>The definitions of the relational operators are the same as for the base template. Interoperable comparisons between T and optional&lt;T&amp;&gt; work as expected. This is not true for the boost optional&lt;T&amp;&gt;.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md4"></a>
make_optional</h2>
<p>With further research, the existing uses of make_optional&lt;X&amp;&gt; seem to be primarily test cases, and deliberate use seems to be exceedingly rare in the wild. Reflector review was much more positive about removing the misleading ability to create an <span class="tt">optional&lt;X&gt;</span> via <span class="tt">make_optional&lt;X&amp;&gt;(x)</span>. In addition, the multiple argument forms can be used to attempt to construct a optional that contains a reference, but this becomes ill formed because of existing mandates at the type level. In order to preserve existing behavior, where make_optional is not well formed if it constructs a reference, changes to <span class="tt">make_optional</span> should be made.</p>
<p>Adding a non-type template parameter as the first template parameter to the single argument <span class="tt">make_optional</span> and mandating that the multi-argument version not request a reference type as the parameter, will diagnose mistaken use of <span class="tt">make_optional</span> and preserve the existing behavior.</p>
<p>Since construction of an object in order to make a reference to it to construct an optional containing a reference would always dangle, there do not seem to be any use cases for the multi-argument or initializer list forms of make_optional for reference types, and the constructor form seems to satisfy all cases for single argument construction of a optional containing a reference, there does not seem to be a need for a factory function for optional over reference.</p>
<p>There was also discussion of using <span class="tt">std::reference_wrapper</span> to indicate reference use, in analogy with std::tuple. Unfortunately there are existing uses of optional over reference_wrapper as a workaround for lack of reference specialization, and it would be a breaking change for such code.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md5"></a>
Trivial construction</h2>
<p>Construction of <span class="tt">optional&lt;T&amp;&gt;</span> should be trivial, because it is straightforward to implement, and <span class="tt">optional&lt;T&gt;</span> is trivial. Boost is not.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6"></a>
Value Category Affects value()</h2>
<p>For several implementations there are distinct overloads for functions depending on value category, with the same implementation. However, this makes it very easy to accidentally steal from the underlying referred to object. Value category should be shallow. Thanks to many people for pointing this out. If `<span class="tt">Deducing </span>this`'' had been used, the problem would have been much more subtle in code review.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7"></a>
Shallow vs Deep const</h2>
<p>There is some implementation divergence in optionals about deep const for <span class="tt">optional&lt;T&amp;&gt;</span>. That is, can the referred to <span class="tt">int</span> be modified through a <span class="tt">const optional&lt;int&amp;&gt;</span>. Does <span class="tt">operator-&gt;()</span> return an <span class="tt">int*</span> or a <span class="tt">const int*</span>, and does <span class="tt">operator*()</span> return an <span class="tt">int&amp;</span> or a <span class="tt">const int&amp;</span>. I believe it is overall more defensible if the <span class="tt">const</span> is shallow as it would be for a `struct ref {int * p;`` where the constness of the struct ref does not affect if the p pointer can be written through. This is consistent with the rebinding behavior being proposed.</p>
<p>Where deeper constness is desired, <span class="tt">optional&lt;const T&amp;&gt;</span> would prevent non const access to the underlying object.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8"></a>
Conditional Explicit</h2>
<p>As in the base template, <span class="tt">explicit</span> is made conditional on the type used to construct the optional. <span class="tt">explicit(!std::is_convertible_v&lt;U, T&gt;)</span>. This is not present in boost::optional, leading to differences in construction between braced initialization and = that can be surprising.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9"></a>
value_or</h2>
<p>After extensive discussion, it seems there is no particularly wonderful solution for <span class="tt">value_or</span> that does not involve a time machine. Implementations of optionals that support reference semantics diverge over the return type, and the current one is arguably wrong, and should use something based on <span class="tt">common_reference_type</span>, which of course did not exist when <span class="tt">optional</span> was standardized.</p>
<p>The weak consensus is to return a <span class="tt">T</span> from <span class="tt">optional&lt;T&amp;&gt;::value_or</span> as this is least likely to cause issues. There was at least one strong objection to this choice, but all other choices had more objections. The author intends to propose free functions <span class="tt">reference_or</span>, <span class="tt">value_or</span>, <span class="tt">or_invoke</span>, and <span class="tt">yield_if</span> over all types modeling optional-like, <span class="tt">concept std::maybe</span>, in the next revision of P1255R12. This would cover <span class="tt">optional</span>, <span class="tt">expected</span>, and pointer types.</p>
<p>Having <span class="tt">value_or</span> return by value also allows the common case of using a literal as the alternative to be expressed concisely.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10"></a>
in_place_t construction</h2>
<p>The reference specialization allows a limited form of in_place construction where the argument can be converted to the appropriate reference without creation of a temporary. As the reference specialization is non-owning, there is no ``place'' for a temporary to be constructed that will not dangle. For cases where the lifetime of the constructed object would match the lifetime of the optional, the temporary can be constructed explicitly, instead.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md11"></a>
Converting assignment</h2>
<p>A similarly limited converting assignment operator is provided for cases where an <span class="tt">optional&lt;U&gt;</span> has a value or refers to a value which can be converted to a <span class="tt">T&amp;</span> without construction of a temporary. In particular, converting an <span class="tt">optional&lt;T&amp;&gt;</span> to an <span class="tt">optional&lt;T const&amp;&gt;</span> is supported.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md12"></a>
Principles for Reification of Design</h1>
<p>Optional must never construct a temporary, or knowingly take the address of an temporary or part of an temporary.</p>
<p>It is always presumed safe to copy the pointer value from an optional, since by induction, it is not dangling.</p>
<p>Optional has no storage, so should never construct a T, it may convert a U to a T, so long as that conversion does not create a temporary.</p>
<p>Constructors that would convert from temporary are marked deleted. They should be sufficiently constrained that it was the correct choice and there is no more general, less constrained constructor that would not have created a dangling pointer.</p>
<p>Failure to compile either by ambiguity or no eligible constructors in the overload set is preferable to optional being responsible for use after free or dangling.</p>
<p>Assignment is always from an optional, which may have been an implicit construction. The assignment cannot throw, the construction/conversion may. The assignment may therefore need annotation converting the rhs if that constructor was explicit. This must not be necessary in the default case of creating an optional reference to an lvalue of the same type.</p>
<p>The model for the constraints and mandates for <span class="tt">optional&lt;T&amp;&gt;</span> is taken from <span class="tt">std::tuple</span> over reference types. The type <span class="tt">std::tuple</span> takes the most care of types in the standard library in dealing with creation of temporaries.</p>
<p>As <span class="tt">optional</span> is designed to be converting, to create instances from arguments that can be used to create the underlying type, constructors should be explicit only where the operations used to create the pointer or the notional reference would be or are explicit.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13"></a>
Construction from temporary</h2>
<p>We disallow construction of <span class="tt">optional&lt;T&amp;&gt;</span> from any type U in which:</p><ul>
<li>the constructor body will create a temporary and bind it to a reference.</li>
<li>a const lvalue reference would be bound to rvalue.</li>
</ul>
<p>An example of the first case would be construction <span class="tt">optional&lt;std::string const&amp;&gt;</span> from <span class="tt">char const*</span>. These cases always dangle.</p>
<p>An example of the second case would be a construction <span class="tt">std::optional&lt;std::string const&amp;&gt;</span> from temporary <span class="tt">std::string</span>.</p>
<p>Prohibiting the second case does prevent some safe uses of the optional as the function parameter.</p>
<p>Given:</p>
<p><span class="tt">void process(std::optional&lt;std::string const&amp;&gt; arg);</span></p>
<p>This will make a <span class="tt">process(std::string("sdfd"))</span> invocation ill-formed, despite the arg being safe to use from within the function body.</p>
<p>This deviates from the design of the `<span class="tt">view'' parameters type, like </span>std::string_view<span class="tt"> or </span>std::span`. However, we believe that this is the right choice due to the following:</p>
<ul>
<li>Only a subset of cases would be working. As an illustration the very similar `process("text")} invocation is ill-formed, due to always being dangling.</li>
<li>Such design leads to the detection of reference to temporaries or local variables when <span class="tt">optional&lt;T const&amp;&gt;</span> is used as the return type.</li>
</ul>
<div class="fragment"><div class="line">std::optional&lt;std::string const&amp;&gt; getValue() {</div>
<div class="line">  std::string localString;</div>
<div class="line">  <span class="keywordflow">return</span> localString; <span class="comment">// Ill-formed.</span></div>
<div class="line">  std::optional&lt;std::string&gt; localOptionalString;</div>
<div class="line">  <span class="keywordflow">return</span> localOptionalString; <span class="comment">// ill-formed</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>One of the main motivational examples of <span class="tt">optional&lt;T const&amp;&gt;</span> is return from a lookup function, and eliminating dangling in such cases outweighs parameter cases.</p>
<p>We are very grateful to Arthur O'Dwyer for his work on P2266R3 accepted in C++23, which makes it possible to implement this correctly.</p>
<ul>
<li>We provide behavior consistent with <span class="tt">reference_wrapper&lt;T const&gt;</span>, that disallows binding to xvalues. We believe that <span class="tt">reference_wrapper&lt;T&gt;</span> is closer in spirit to <span class="tt">optional&lt;T&amp;&gt;</span> than any view type. It certainly shares some of the features.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md14"></a>
Deleting dangling overloads</h2>
<p>To achieve the dangling safety expressed before, the constructor is marked deleted if it would lead to binding of the reference to temporary or the xvalue. However, deleted constructors are still considered to be candidates during overload resolution, leading to ambiguity in the following examples:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> process(std::optional&lt;std::string const&amp;&gt;);</div>
<div class="line"><span class="keywordtype">void</span> process(std::optional&lt;char const* const&amp;&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> test() {</div>
<div class="line">  <span class="keywordtype">char</span> <span class="keyword">const</span>* cstr = <span class="stringliteral">&quot;Text&quot;</span>;</div>
<div class="line">  std::string s = cstr;</div>
<div class="line">  process(s); <span class="comment">// Picks, optional&lt;std::string const&amp;&gt; overload</span></div>
<div class="line">  process(cstr); <span class="comment">// Ambiguous, but only std::optional&lt;char const* const&amp;&gt; is not dangling</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>During the reflector discussion, an option of an alternate design was presented, where the dangling overload would be constrained, and eliminated from the overload set.</p>
<p>We strongly oppose changing this behavior, as:</p><ul>
<li>We think that it is impossible to detect temporary binding to xvalue in such a design.</li>
<li>The behavior we propose is consistent with the behavior for optional for object types</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> processVal(std::optional&lt;std::string&gt;);</div>
<div class="line"><span class="keywordtype">void</span> processVal(std::optional&lt;char const*&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> test() {</div>
<div class="line">  <span class="keywordtype">char</span> <span class="keyword">const</span>* cstr = <span class="stringliteral">&quot;Text&quot;</span>;</div>
<div class="line">  std::string s = cstr;</div>
<div class="line">  processVal(s); <span class="comment">// Picks std::string overload</span></div>
<div class="line">  processVal(cstr); <span class="comment">// Ambiguous</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>As language in general treats functions accepting by value and by const reference in the same manner during overload resolution, we believe achieving this consistency is a feature.</p>
<p>The design that was introduced by <span class="tt">std::tuple</span>, and <span class="tt">std::pair</span>, for references, is followed, where the detection of dangling does not affect the results of overload resolution and instead makes a call that would dangle be ill-formed and diagnosed.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md15"></a>
Assignment of optional&lt;T&amp;&gt;</h2>
<p>In the case of <span class="tt">optional&lt;T&amp;&gt;</span>, any assignment operation is equivalent to assigning a pointer, and there is no observable difference between: using converting assignment from <span class="tt">U&amp;&amp;</span> or <span class="tt">optional&lt;U&gt;</span> constructing temporary <span class="tt">optional&lt;T&amp;&gt;</span>, and then assigning it to it.</p>
<p>This observation allows us to provide only copy-assignment for <span class="tt">optional&lt;T&amp;&gt;</span>, instead of a set of converting assignments, that would need to replicate the signatures of constructors and their constraints. Assignment from any other value is handled by first implicitly constructing <span class="tt">optional&lt;T&amp;&gt;</span> and then using copy-assignment. Move-assignment is the same as copy-assignment, since only pointer copy is involved.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
Copy and Assignment of optional&lt;U&amp;&gt;&amp;&amp; to optional&lt;T&gt;</h2>
<p>Care must be take to prevent the assignment of a movable optional to disallow the copy or assignment of the underlying referred to value to be stolen. The <span class="tt">optional&lt;T&gt;::optional&lt;U&amp;&gt; const&amp;</span> assignment or copy constructor should be used instead, which also needs to check slightly different constraints for <span class="tt">converts-from-any-cvref</span> and for testing <span class="tt">is_assignable</span>. We thank Jan Kokem√ºller for uncovering this bug. The bug seems to be present in many optional implementations that support references. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
