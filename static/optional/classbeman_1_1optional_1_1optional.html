<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>beman::optional: beman::optional::optional&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
 <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
 <script type="text/javascript">
     DoxygenAwesomeDarkModeToggle.init()
 </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="beman-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">beman::optional
   </div>
   <div id="projectbrief">Optional Values and References</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classbeman_1_1optional_1_1optional.html','','classbeman_1_1optional_1_1optional-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">beman::optional::optional&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Optional Objects.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="optional_8hpp_source.html">optional.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aefbcf8b894d0bf8d5bbe22cd12f2765f" id="r_aefbcf8b894d0bf8d5bbe22cd12f2765f"><td class="memItemLeft"><a id="aefbcf8b894d0bf8d5bbe22cd12f2765f" name="aefbcf8b894d0bf8d5bbe22cd12f2765f"></a>
using&#160;</td><td class="memItemRight"><b>value_type</b> = T</td></tr>
<tr class="memdesc:aefbcf8b894d0bf8d5bbe22cd12f2765f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for the value type contained in the optional. <br /></td></tr>
<tr class="memitem:af18ae5651fcc0ed78f0cab2a85ad8a07" id="r_af18ae5651fcc0ed78f0cab2a85ad8a07"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#af18ae5651fcc0ed78f0cab2a85ad8a07">iterator</a></td></tr>
<tr class="memdesc:af18ae5651fcc0ed78f0cab2a85ad8a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for the iterator type of the optional.  <br /></td></tr>
<tr class="memitem:ac098cfd77cfd048a49d2d535704b4344" id="r_ac098cfd77cfd048a49d2d535704b4344"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#ac098cfd77cfd048a49d2d535704b4344">const_iterator</a></td></tr>
<tr class="memdesc:ac098cfd77cfd048a49d2d535704b4344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for the const iterator type of the optional.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afa442c06abd82de8cbabeafdeccf23a8" id="r_afa442c06abd82de8cbabeafdeccf23a8"><td class="memItemLeft"><a id="afa442c06abd82de8cbabeafdeccf23a8" name="afa442c06abd82de8cbabeafdeccf23a8"></a>
constexpr&#160;</td><td class="memItemRight"><b>optional</b> () noexcept</td></tr>
<tr class="memdesc:afa442c06abd82de8cbabeafdeccf23a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructs an empty optional. <br /></td></tr>
<tr class="memitem:ab5e1df4d22f084ccc18f7f776fc06411" id="r_ab5e1df4d22f084ccc18f7f776fc06411"><td class="memItemLeft"><a id="ab5e1df4d22f084ccc18f7f776fc06411" name="ab5e1df4d22f084ccc18f7f776fc06411"></a>
constexpr&#160;</td><td class="memItemRight"><b>optional</b> (<a class="el" href="structbeman_1_1optional_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="memdesc:ab5e1df4d22f084ccc18f7f776fc06411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty optional. <br /></td></tr>
<tr class="memitem:a6e96bf0926389ddfd0f83e6f7d11f9e7" id="r_a6e96bf0926389ddfd0f83e6f7d11f9e7"><td class="memItemLeft"><a id="a6e96bf0926389ddfd0f83e6f7d11f9e7" name="a6e96bf0926389ddfd0f83e6f7d11f9e7"></a>
constexpr&#160;</td><td class="memItemRight"><b>optional</b> (const optional &amp;rhs)</td></tr>
<tr class="memdesc:a6e96bf0926389ddfd0f83e6f7d11f9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs the value from <code class="param">rhs</code> if it has one. <br /></td></tr>
<tr class="memitem:a57d14f0bedc03b049d37dcd96aa7f3fe" id="r_a57d14f0bedc03b049d37dcd96aa7f3fe"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><a class="el" href="#a57d14f0bedc03b049d37dcd96aa7f3fe">optional</a> (const optional &amp;)=default</td></tr>
<tr class="memdesc:a57d14f0bedc03b049d37dcd96aa7f3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs the value from <code class="param">rhs</code> if it has one.  <br /></td></tr>
<tr class="memitem:ad2c3f56b24c61b085b53cd9688199de1" id="r_ad2c3f56b24c61b085b53cd9688199de1"><td class="memItemLeft"><a id="ad2c3f56b24c61b085b53cd9688199de1" name="ad2c3f56b24c61b085b53cd9688199de1"></a>
constexpr&#160;</td><td class="memItemRight"><b>optional</b> (optional &amp;&amp;rhs) noexcept(std::is_nothrow_move_constructible_v&lt; T &gt;)</td></tr>
<tr class="memdesc:ad2c3f56b24c61b085b53cd9688199de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs the value from <code class="param">rhs</code> if it has one. <br /></td></tr>
<tr class="memitem:a8c1214300c7a79c170c716bb22824b2c" id="r_a8c1214300c7a79c170c716bb22824b2c"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><a class="el" href="#a8c1214300c7a79c170c716bb22824b2c">optional</a> (optional &amp;&amp;)=default</td></tr>
<tr class="memdesc:a8c1214300c7a79c170c716bb22824b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs the value from <code class="param">rhs</code> if it has one.  <br /></td></tr>
<tr class="memitem:af27e6b6d80787e82db114a3be987512f" id="r_af27e6b6d80787e82db114a3be987512f"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; <br />
requires std::is_constructible_v&lt;T, Args...&gt;</td></tr>
<tr class="memitem:af27e6b6d80787e82db114a3be987512f template"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><a class="el" href="#af27e6b6d80787e82db114a3be987512f">optional</a> (<a class="el" href="structbeman_1_1optional_1_1in__place__t.html">in_place_t</a>, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:af27e6b6d80787e82db114a3be987512f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the value in-place using the given arguments.  <br /></td></tr>
<tr class="memitem:af75c591a86a8ee7d0185e67189234039" id="r_af75c591a86a8ee7d0185e67189234039"><td class="memTemplParams" colspan="2">template&lt;class U, class... Args&gt; <br />
requires std::is_constructible_v&lt;T, std::initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</td></tr>
<tr class="memitem:af75c591a86a8ee7d0185e67189234039 template"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><a class="el" href="#af75c591a86a8ee7d0185e67189234039">optional</a> (<a class="el" href="structbeman_1_1optional_1_1in__place__t.html">in_place_t</a>, std::initializer_list&lt; U &gt; il, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:af75c591a86a8ee7d0185e67189234039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the value in-place using the given arguments.  <br /></td></tr>
<tr class="memitem:ac4146fd29dd405c306bb8a30fba3a989" id="r_ac4146fd29dd405c306bb8a30fba3a989"><td class="memTemplParams" colspan="2">template&lt;class U = T&gt; <br />
requires detail::enable_forward_value&lt;T, U&gt;</td></tr>
<tr class="memitem:ac4146fd29dd405c306bb8a30fba3a989 template"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><a class="el" href="#ac4146fd29dd405c306bb8a30fba3a989">explicit</a> (!std::is_convertible_v&lt; U, T &gt;) optional(U &amp;&amp;u)</td></tr>
<tr class="memdesc:ac4146fd29dd405c306bb8a30fba3a989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the value from <code class="param">u</code>, forwarding it if necessary.  <br /></td></tr>
<tr class="memitem:ab2d2eb0bf74ff29513838d9641479199" id="r_ab2d2eb0bf74ff29513838d9641479199"><td class="memTemplParams" colspan="2">template&lt;class U&gt; <br />
requires (detail::enable_from_other&lt;T, U, const U&amp;&gt;)</td></tr>
<tr class="memitem:ab2d2eb0bf74ff29513838d9641479199 template"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><a class="el" href="#ab2d2eb0bf74ff29513838d9641479199">explicit</a> (!std::is_convertible_v&lt; U, T &gt;) optional(const optional&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab2d2eb0bf74ff29513838d9641479199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the value from <code class="param">rhs</code> if it has one.  <br /></td></tr>
<tr class="memitem:ad3b346735cb7cf83a810ac6c0b30b166" id="r_ad3b346735cb7cf83a810ac6c0b30b166"><td class="memTemplParams" colspan="2"><a id="ad3b346735cb7cf83a810ac6c0b30b166" name="ad3b346735cb7cf83a810ac6c0b30b166"></a>
template&lt;class U&gt; <br />
requires (detail::enable_from_other&lt;T, U, U &amp;&amp;&gt;)</td></tr>
<tr class="memitem:ad3b346735cb7cf83a810ac6c0b30b166 template"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><b>explicit</b> (!std::is_convertible_v&lt; U, T &gt;) optional(optional&lt; U &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ad3b346735cb7cf83a810ac6c0b30b166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the value from <code class="param">rhs</code> if it has one. <br /></td></tr>
<tr class="memitem:af2f6a1107b25308a07cbd4b80482531a" id="r_af2f6a1107b25308a07cbd4b80482531a"><td class="memItemLeft"><a id="af2f6a1107b25308a07cbd4b80482531a" name="af2f6a1107b25308a07cbd4b80482531a"></a>
constexpr&#160;</td><td class="memItemRight"><b>~optional</b> ()=default</td></tr>
<tr class="memdesc:af2f6a1107b25308a07cbd4b80482531a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the optional. <br /></td></tr>
<tr class="memitem:aa6f4357c31a7ffb15ccb92fe23465fca" id="r_aa6f4357c31a7ffb15ccb92fe23465fca"><td class="memItemLeft"><a id="aa6f4357c31a7ffb15ccb92fe23465fca" name="aa6f4357c31a7ffb15ccb92fe23465fca"></a>
constexpr&#160;</td><td class="memItemRight"><b>~optional</b> ()</td></tr>
<tr class="memdesc:aa6f4357c31a7ffb15ccb92fe23465fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the optional and its value if it has one. <br /></td></tr>
<tr class="memitem:a475ab64582866ead22f7af2966455f23" id="r_a475ab64582866ead22f7af2966455f23"><td class="memItemLeft"><a id="a475ab64582866ead22f7af2966455f23" name="a475ab64582866ead22f7af2966455f23"></a>
constexpr optional &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (<a class="el" href="structbeman_1_1optional_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="memdesc:a475ab64582866ead22f7af2966455f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the optional to an empty state. <br /></td></tr>
<tr class="memitem:a1630d1de962bdad40fb5c43083a935e1" id="r_a1630d1de962bdad40fb5c43083a935e1"><td class="memItemLeft"><a id="a1630d1de962bdad40fb5c43083a935e1" name="a1630d1de962bdad40fb5c43083a935e1"></a>
constexpr optional &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (const optional &amp;rhs)</td></tr>
<tr class="memdesc:a1630d1de962bdad40fb5c43083a935e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assigns the value from <code class="param">rhs</code> if it has one. <br /></td></tr>
<tr class="memitem:acc77319af3acf2481397213952ff17d3" id="r_acc77319af3acf2481397213952ff17d3"><td class="memItemLeft">constexpr optional &amp;&#160;</td><td class="memItemRight"><a class="el" href="#acc77319af3acf2481397213952ff17d3">operator=</a> (const optional &amp;)=default</td></tr>
<tr class="memdesc:acc77319af3acf2481397213952ff17d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assigns the value from <code class="param">rhs</code> if it has one.  <br /></td></tr>
<tr class="memitem:a2e2d9f8e12fbf79f210708a520646674" id="r_a2e2d9f8e12fbf79f210708a520646674"><td class="memItemLeft"><a id="a2e2d9f8e12fbf79f210708a520646674" name="a2e2d9f8e12fbf79f210708a520646674"></a>
constexpr optional &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (optional &amp;&amp;rhs) noexcept(std::is_nothrow_move_constructible_v&lt; T &gt;)</td></tr>
<tr class="memdesc:a2e2d9f8e12fbf79f210708a520646674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assigns the value from <code class="param">rhs</code> if it has one. <br /></td></tr>
<tr class="memitem:aaa527f81b17e72ae27f347dbb9aee19b" id="r_aaa527f81b17e72ae27f347dbb9aee19b"><td class="memItemLeft"><a id="aaa527f81b17e72ae27f347dbb9aee19b" name="aaa527f81b17e72ae27f347dbb9aee19b"></a>
constexpr optional &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (optional &amp;&amp;)=default</td></tr>
<tr class="memdesc:aaa527f81b17e72ae27f347dbb9aee19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assigns the value from <code class="param">rhs</code> if it has one. <br /></td></tr>
<tr class="memitem:adb7fe1c0bcc29a9c97c3410c9537ff70" id="r_adb7fe1c0bcc29a9c97c3410c9537ff70"><td class="memTemplParams" colspan="2">template&lt;class U = T&gt; <br />
requires detail::enable_assign_forward&lt;T, U&gt;</td></tr>
<tr class="memitem:adb7fe1c0bcc29a9c97c3410c9537ff70 template"><td class="memItemLeft">constexpr optional &amp;&#160;</td><td class="memItemRight"><a class="el" href="#adb7fe1c0bcc29a9c97c3410c9537ff70">operator=</a> (U &amp;&amp;u)</td></tr>
<tr class="memdesc:adb7fe1c0bcc29a9c97c3410c9537ff70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contained value from <code class="param">u</code>, destroying the old value if there.  <br /></td></tr>
<tr class="memitem:aa7163581d56c09cbdfb3ee228a40562d" id="r_aa7163581d56c09cbdfb3ee228a40562d"><td class="memTemplParams" colspan="2"><a id="aa7163581d56c09cbdfb3ee228a40562d" name="aa7163581d56c09cbdfb3ee228a40562d"></a>
template&lt;class U&gt; <br />
requires (detail::enable_assign_from_other&lt;T, U, const U&amp;&gt;)</td></tr>
<tr class="memitem:aa7163581d56c09cbdfb3ee228a40562d template"><td class="memItemLeft">constexpr optional &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (const optional&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa7163581d56c09cbdfb3ee228a40562d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contained value from <code class="param">rhs</code> if it has one, destroying the old value if there. <br /></td></tr>
<tr class="memitem:aaaeb315b6e8cb099968dd7fc51634c3e" id="r_aaaeb315b6e8cb099968dd7fc51634c3e"><td class="memTemplParams" colspan="2"><a id="aaaeb315b6e8cb099968dd7fc51634c3e" name="aaaeb315b6e8cb099968dd7fc51634c3e"></a>
template&lt;class U&gt; <br />
requires (detail::enable_assign_from_other&lt;T, U, U&gt;)</td></tr>
<tr class="memitem:aaaeb315b6e8cb099968dd7fc51634c3e template"><td class="memItemLeft">constexpr optional &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (optional&lt; U &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:aaaeb315b6e8cb099968dd7fc51634c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contained value from <code class="param">rhs</code> if it has one, destroying the old value if there. <br /></td></tr>
<tr class="memitem:ac20ea14c0765679cb2bf4c74b5c82bd5" id="r_ac20ea14c0765679cb2bf4c74b5c82bd5"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ac20ea14c0765679cb2bf4c74b5c82bd5 template"><td class="memItemLeft">constexpr T &amp;&#160;</td><td class="memItemRight"><a class="el" href="#ac20ea14c0765679cb2bf4c74b5c82bd5">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac20ea14c0765679cb2bf4c74b5c82bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the value in-place, destroying the current one if there.  <br /></td></tr>
<tr class="memitem:a3057f723870a4c2c67ed0be186a96481" id="r_a3057f723870a4c2c67ed0be186a96481"><td class="memTemplParams" colspan="2">template&lt;class U, class... Args&gt; </td></tr>
<tr class="memitem:a3057f723870a4c2c67ed0be186a96481 template"><td class="memItemLeft">constexpr T &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a3057f723870a4c2c67ed0be186a96481">emplace</a> (std::initializer_list&lt; U &gt; il, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3057f723870a4c2c67ed0be186a96481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the value in-place using the given arguments, destroying the current one if there.  <br /></td></tr>
<tr class="memitem:a3aa22eefcb8377a2ff2c3eaba050cc23" id="r_a3aa22eefcb8377a2ff2c3eaba050cc23"><td class="memItemLeft">constexpr void&#160;</td><td class="memItemRight"><a class="el" href="#a3aa22eefcb8377a2ff2c3eaba050cc23">swap</a> (optional &amp;rhs) noexcept(std::is_nothrow_move_constructible&lt; T &gt;<a class="el" href="#a403cec6d7cc62ed49dc6c1a932da6de3">::value</a> &amp;&amp;std::is_nothrow_swappable&lt; T &gt;<a class="el" href="#a403cec6d7cc62ed49dc6c1a932da6de3">::value</a>)</td></tr>
<tr class="memdesc:a3aa22eefcb8377a2ff2c3eaba050cc23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this optional with the other.  <br /></td></tr>
<tr class="memitem:a8b80251c803ff7de9e28e4e3cf16a6f2" id="r_a8b80251c803ff7de9e28e4e3cf16a6f2"><td class="memItemLeft">constexpr <a class="el" href="#af18ae5651fcc0ed78f0cab2a85ad8a07">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a8b80251c803ff7de9e28e4e3cf16a6f2">begin</a> () noexcept</td></tr>
<tr class="memdesc:a8b80251c803ff7de9e28e4e3cf16a6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the optional.  <br /></td></tr>
<tr class="memitem:a07d0a37da89665a15c7910afbf8e199c" id="r_a07d0a37da89665a15c7910afbf8e199c"><td class="memItemLeft">constexpr <a class="el" href="#ac098cfd77cfd048a49d2d535704b4344">const_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a07d0a37da89665a15c7910afbf8e199c">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a07d0a37da89665a15c7910afbf8e199c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the beginning of the optional.  <br /></td></tr>
<tr class="memitem:a59208fb74a69302b36ab42fa4d61ce74" id="r_a59208fb74a69302b36ab42fa4d61ce74"><td class="memItemLeft">constexpr <a class="el" href="#af18ae5651fcc0ed78f0cab2a85ad8a07">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a59208fb74a69302b36ab42fa4d61ce74">end</a> () noexcept</td></tr>
<tr class="memdesc:a59208fb74a69302b36ab42fa4d61ce74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of the optional.  <br /></td></tr>
<tr class="memitem:ab6746328dd0c1ff4e363f7a5e89e910e" id="r_ab6746328dd0c1ff4e363f7a5e89e910e"><td class="memItemLeft">constexpr <a class="el" href="#ac098cfd77cfd048a49d2d535704b4344">const_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#ab6746328dd0c1ff4e363f7a5e89e910e">end</a> () const noexcept</td></tr>
<tr class="memdesc:ab6746328dd0c1ff4e363f7a5e89e910e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the end of the optional.  <br /></td></tr>
<tr class="memitem:aa75425844992799ee8cfb7f1ab7c84ce" id="r_aa75425844992799ee8cfb7f1ab7c84ce"><td class="memItemLeft"><a id="aa75425844992799ee8cfb7f1ab7c84ce" name="aa75425844992799ee8cfb7f1ab7c84ce"></a>
constexpr const T *&#160;</td><td class="memItemRight"><b>operator-&gt;</b> () const</td></tr>
<tr class="memdesc:aa75425844992799ee8cfb7f1ab7c84ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the contained value. <br /></td></tr>
<tr class="memitem:a11514681edbb160cf2efc43ef55c5528" id="r_a11514681edbb160cf2efc43ef55c5528"><td class="memItemLeft">constexpr T *&#160;</td><td class="memItemRight"><a class="el" href="#a11514681edbb160cf2efc43ef55c5528">operator-&gt;</a> ()</td></tr>
<tr class="memdesc:a11514681edbb160cf2efc43ef55c5528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the contained value.  <br /></td></tr>
<tr class="memitem:af6278cfdf226813b44e48bcca9e9c160" id="r_af6278cfdf226813b44e48bcca9e9c160"><td class="memItemLeft">constexpr T &amp;&#160;</td><td class="memItemRight"><a class="el" href="#af6278cfdf226813b44e48bcca9e9c160">operator*</a> () &amp;</td></tr>
<tr class="memdesc:af6278cfdf226813b44e48bcca9e9c160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the contained value.  <br /></td></tr>
<tr class="memitem:ae2066b2ca9b88bda6f8a31f75c334b00" id="r_ae2066b2ca9b88bda6f8a31f75c334b00"><td class="memItemLeft">constexpr const T &amp;&#160;</td><td class="memItemRight"><a class="el" href="#ae2066b2ca9b88bda6f8a31f75c334b00">operator*</a> () const &amp;</td></tr>
<tr class="memdesc:ae2066b2ca9b88bda6f8a31f75c334b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the contained value.  <br /></td></tr>
<tr class="memitem:aa8cf9e9651cd496ce32f7b7bcb810874" id="r_aa8cf9e9651cd496ce32f7b7bcb810874"><td class="memItemLeft">constexpr T &amp;&amp;&#160;</td><td class="memItemRight"><a class="el" href="#aa8cf9e9651cd496ce32f7b7bcb810874">operator*</a> () &amp;&amp;</td></tr>
<tr class="memdesc:aa8cf9e9651cd496ce32f7b7bcb810874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the contained value.  <br /></td></tr>
<tr class="memitem:a2b3f8f20f9fc411b656ebcc9c2a45fbc" id="r_a2b3f8f20f9fc411b656ebcc9c2a45fbc"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><a class="el" href="#a2b3f8f20f9fc411b656ebcc9c2a45fbc">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:a2b3f8f20f9fc411b656ebcc9c2a45fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the optional to a boolean indicating whether it has a value.  <br /></td></tr>
<tr class="memitem:a30353c697fc17e7b421cde25cab03d24" id="r_a30353c697fc17e7b421cde25cab03d24"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#a30353c697fc17e7b421cde25cab03d24">has_value</a> () const noexcept</td></tr>
<tr class="memdesc:a30353c697fc17e7b421cde25cab03d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the optional has a value.  <br /></td></tr>
<tr class="memitem:a403cec6d7cc62ed49dc6c1a932da6de3" id="r_a403cec6d7cc62ed49dc6c1a932da6de3"><td class="memItemLeft">constexpr T &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a403cec6d7cc62ed49dc6c1a932da6de3">value</a> () &amp;</td></tr>
<tr class="memdesc:a403cec6d7cc62ed49dc6c1a932da6de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the contained value.  <br /></td></tr>
<tr class="memitem:a78ed5dfa0c06503c1a682e6790727498" id="r_a78ed5dfa0c06503c1a682e6790727498"><td class="memItemLeft">constexpr const T &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a78ed5dfa0c06503c1a682e6790727498">value</a> () const &amp;</td></tr>
<tr class="memdesc:a78ed5dfa0c06503c1a682e6790727498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the contained value.  <br /></td></tr>
<tr class="memitem:ad03f9b933291169eeba5e53cdfd50867" id="r_ad03f9b933291169eeba5e53cdfd50867"><td class="memItemLeft">constexpr T &amp;&amp;&#160;</td><td class="memItemRight"><a class="el" href="#ad03f9b933291169eeba5e53cdfd50867">value</a> () &amp;&amp;</td></tr>
<tr class="memdesc:ad03f9b933291169eeba5e53cdfd50867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the contained value.  <br /></td></tr>
<tr class="memitem:a1a4d7b910633a73a4aecaac930684aef" id="r_a1a4d7b910633a73a4aecaac930684aef"><td class="memTemplParams" colspan="2">template&lt;class U = std::remove_cv_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a1a4d7b910633a73a4aecaac930684aef template"><td class="memItemLeft">constexpr std::remove_cv_t&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a1a4d7b910633a73a4aecaac930684aef">value_or</a> (U &amp;&amp;u) const &amp;</td></tr>
<tr class="memdesc:a1a4d7b910633a73a4aecaac930684aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained value if there is one, otherwise returns <span class="tt">u</span>.  <br /></td></tr>
<tr class="memitem:ac096c3c3ac924809a2a9d24aa88b30c1" id="r_ac096c3c3ac924809a2a9d24aa88b30c1"><td class="memTemplParams" colspan="2">template&lt;class U = std::remove_cv_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ac096c3c3ac924809a2a9d24aa88b30c1 template"><td class="memItemLeft">constexpr std::remove_cv_t&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#ac096c3c3ac924809a2a9d24aa88b30c1">value_or</a> (U &amp;&amp;u) &amp;&amp;</td></tr>
<tr class="memdesc:ac096c3c3ac924809a2a9d24aa88b30c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained value if there is one, otherwise returns <span class="tt">u</span>.  <br /></td></tr>
<tr class="memitem:a4e2cee231a67ca48f82715cdd334bf94" id="r_a4e2cee231a67ca48f82715cdd334bf94"><td class="memTemplParams" colspan="2">template&lt;class F&gt; </td></tr>
<tr class="memitem:a4e2cee231a67ca48f82715cdd334bf94 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#a4e2cee231a67ca48f82715cdd334bf94">and_then</a> (F &amp;&amp;f) &amp;</td></tr>
<tr class="memdesc:a4e2cee231a67ca48f82715cdd334bf94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to the contained value if there is one.  <br /></td></tr>
<tr class="memitem:a09d36e0c91acecd4dd1983c8159f8c85" id="r_a09d36e0c91acecd4dd1983c8159f8c85"><td class="memTemplParams" colspan="2">template&lt;class F&gt; </td></tr>
<tr class="memitem:a09d36e0c91acecd4dd1983c8159f8c85 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#a09d36e0c91acecd4dd1983c8159f8c85">and_then</a> (F &amp;&amp;f) &amp;&amp;</td></tr>
<tr class="memdesc:a09d36e0c91acecd4dd1983c8159f8c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to the contained value if there is one.  <br /></td></tr>
<tr class="memitem:ab90dcd5e2580af7c3e885428a939cfe4" id="r_ab90dcd5e2580af7c3e885428a939cfe4"><td class="memTemplParams" colspan="2">template&lt;class F&gt; </td></tr>
<tr class="memitem:ab90dcd5e2580af7c3e885428a939cfe4 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#ab90dcd5e2580af7c3e885428a939cfe4">and_then</a> (F &amp;&amp;f) const &amp;</td></tr>
<tr class="memdesc:ab90dcd5e2580af7c3e885428a939cfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to the contained value if there is one.  <br /></td></tr>
<tr class="memitem:a1f777fa3e547b9e56ad0633bc8714133" id="r_a1f777fa3e547b9e56ad0633bc8714133"><td class="memTemplParams" colspan="2">template&lt;class F&gt; </td></tr>
<tr class="memitem:a1f777fa3e547b9e56ad0633bc8714133 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#a1f777fa3e547b9e56ad0633bc8714133">and_then</a> (F &amp;&amp;f) const &amp;&amp;</td></tr>
<tr class="memdesc:a1f777fa3e547b9e56ad0633bc8714133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to the contained value if there is one.  <br /></td></tr>
<tr class="memitem:ab409242d8b0b3ed4fda5d4c66e3e2db6" id="r_ab409242d8b0b3ed4fda5d4c66e3e2db6"><td class="memTemplParams" colspan="2">template&lt;class F&gt; </td></tr>
<tr class="memitem:ab409242d8b0b3ed4fda5d4c66e3e2db6 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#ab409242d8b0b3ed4fda5d4c66e3e2db6">transform</a> (F &amp;&amp;f) &amp;</td></tr>
<tr class="memdesc:ab409242d8b0b3ed4fda5d4c66e3e2db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an optional containing the result of applying <code class="param">f</code> to the contained value, or an empty optional if there is no contained value.  <br /></td></tr>
<tr class="memitem:a6989e2a3dc4e30dd38a1a8d689616f05" id="r_a6989e2a3dc4e30dd38a1a8d689616f05"><td class="memTemplParams" colspan="2">template&lt;class F&gt; </td></tr>
<tr class="memitem:a6989e2a3dc4e30dd38a1a8d689616f05 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#a6989e2a3dc4e30dd38a1a8d689616f05">transform</a> (F &amp;&amp;f) &amp;&amp;</td></tr>
<tr class="memdesc:a6989e2a3dc4e30dd38a1a8d689616f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an optional containing the result of applying <code class="param">f</code> to the contained value, or an empty optional if there is no contained value.  <br /></td></tr>
<tr class="memitem:ae7aae84b3e296d65d93b132bca8e79dc" id="r_ae7aae84b3e296d65d93b132bca8e79dc"><td class="memTemplParams" colspan="2">template&lt;class F&gt; </td></tr>
<tr class="memitem:ae7aae84b3e296d65d93b132bca8e79dc template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#ae7aae84b3e296d65d93b132bca8e79dc">transform</a> (F &amp;&amp;f) const &amp;</td></tr>
<tr class="memdesc:ae7aae84b3e296d65d93b132bca8e79dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an optional containing the result of applying <code class="param">f</code> to the contained value, or an empty optional if there is no contained value.  <br /></td></tr>
<tr class="memitem:ae686bd0b6e17116c73a1c2aa2cae116d" id="r_ae686bd0b6e17116c73a1c2aa2cae116d"><td class="memTemplParams" colspan="2">template&lt;class F&gt; </td></tr>
<tr class="memitem:ae686bd0b6e17116c73a1c2aa2cae116d template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#ae686bd0b6e17116c73a1c2aa2cae116d">transform</a> (F &amp;&amp;f) const &amp;&amp;</td></tr>
<tr class="memdesc:ae686bd0b6e17116c73a1c2aa2cae116d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an optional containing the result of applying <code class="param">f</code> to the contained value, or an empty optional if there is no contained value.  <br /></td></tr>
<tr class="memitem:a7f407bdbf5ebf9cc166b0d7659a4001c" id="r_a7f407bdbf5ebf9cc166b0d7659a4001c"><td class="memTemplParams" colspan="2">template&lt;class F&gt; <br />
requires (std::invocable&lt;F&gt; &amp;&amp; std::copy_constructible&lt;T&gt;)</td></tr>
<tr class="memitem:a7f407bdbf5ebf9cc166b0d7659a4001c template"><td class="memItemLeft">constexpr optional&#160;</td><td class="memItemRight"><a class="el" href="#a7f407bdbf5ebf9cc166b0d7659a4001c">or_else</a> (F &amp;&amp;f) const &amp;</td></tr>
<tr class="memdesc:a7f407bdbf5ebf9cc166b0d7659a4001c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an optional containing the contained value if it has one, or the result of applying <code class="param">f</code> to the optional if it does not.  <br /></td></tr>
<tr class="memitem:abbd48b7ce4f8c980bc92a40f0f886449" id="r_abbd48b7ce4f8c980bc92a40f0f886449"><td class="memTemplParams" colspan="2">template&lt;class F&gt; <br />
requires (std::invocable&lt;F&gt; &amp;&amp; std::move_constructible&lt;T&gt;)</td></tr>
<tr class="memitem:abbd48b7ce4f8c980bc92a40f0f886449 template"><td class="memItemLeft">constexpr optional&#160;</td><td class="memItemRight"><a class="el" href="#abbd48b7ce4f8c980bc92a40f0f886449">or_else</a> (F &amp;&amp;f) &amp;&amp;</td></tr>
<tr class="memdesc:abbd48b7ce4f8c980bc92a40f0f886449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an optional containing the contained value if it has one, or the result of calling <code class="param">f</code> if it does not.  <br /></td></tr>
<tr class="memitem:a1aecd22269bb50bb1b0ca38a893f8db9" id="r_a1aecd22269bb50bb1b0ca38a893f8db9"><td class="memItemLeft"><a id="a1aecd22269bb50bb1b0ca38a893f8db9" name="a1aecd22269bb50bb1b0ca38a893f8db9"></a>
constexpr void&#160;</td><td class="memItemRight"><b>reset</b> () noexcept</td></tr>
<tr class="memdesc:a1aecd22269bb50bb1b0ca38a893f8db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the optional to an empty state, destroying the contained value if there is one. <br /></td></tr>
<tr class="memitem:a143d2cbf17edbfcc85abdb78f666dc77" id="r_a143d2cbf17edbfcc85abdb78f666dc77"><td class="memTemplParams" colspan="2"><a id="a143d2cbf17edbfcc85abdb78f666dc77" name="a143d2cbf17edbfcc85abdb78f666dc77"></a>
template&lt;class U&gt; <br />
requires detail::enable_forward_value&lt;T, U&gt;</td></tr>
<tr class="memitem:a143d2cbf17edbfcc85abdb78f666dc77 template"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><b>optional</b> (U &amp;&amp;u)</td></tr>
<tr class="memdesc:a143d2cbf17edbfcc85abdb78f666dc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the contained value with <span class="tt">u</span>. <br /></td></tr>
<tr class="memitem:a14058dbc4c83fac2455df7488a73b21a" id="r_a14058dbc4c83fac2455df7488a73b21a"><td class="memTemplParams" colspan="2"><a id="a14058dbc4c83fac2455df7488a73b21a" name="a14058dbc4c83fac2455df7488a73b21a"></a>
template&lt;class U&gt; <br />
requires (detail::enable_from_other&lt;T, U, const U&amp;&gt;)</td></tr>
<tr class="memitem:a14058dbc4c83fac2455df7488a73b21a template"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><b>optional</b> (const optional&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a14058dbc4c83fac2455df7488a73b21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting copy constructor. <br /></td></tr>
<tr class="memitem:ab82258f34dc1cdd58b5c58687da00e04" id="r_ab82258f34dc1cdd58b5c58687da00e04"><td class="memTemplParams" colspan="2"><a id="ab82258f34dc1cdd58b5c58687da00e04" name="ab82258f34dc1cdd58b5c58687da00e04"></a>
template&lt;class U&gt; <br />
requires (detail::enable_from_other&lt;T, U, U &amp;&amp;&gt;)</td></tr>
<tr class="memitem:ab82258f34dc1cdd58b5c58687da00e04 template"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><b>optional</b> (optional&lt; U &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ab82258f34dc1cdd58b5c58687da00e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting move constructor. <br /></td></tr>
<tr class="memitem:a2f66e32d69388df3d7e3acb601058776" id="r_a2f66e32d69388df3d7e3acb601058776"><td class="memTemplParams" colspan="2">template&lt;class U&gt; <br />
requires detail::enable_assign_forward&lt;T, U&gt;</td></tr>
<tr class="memitem:a2f66e32d69388df3d7e3acb601058776 template"><td class="memItemLeft">constexpr optional&lt; T &gt; &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a2f66e32d69388df3d7e3acb601058776">operator=</a> (U &amp;&amp;u)</td></tr>
<tr class="memitem:a49295670a71a3219a5d308bd20366a82" id="r_a49295670a71a3219a5d308bd20366a82"><td class="memTemplParams" colspan="2">template&lt;class U&gt; <br />
requires (detail::enable_assign_from_other&lt;T, U, const U&amp;&gt;)</td></tr>
<tr class="memitem:a49295670a71a3219a5d308bd20366a82 template"><td class="memItemLeft">constexpr optional&lt; T &gt; &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a49295670a71a3219a5d308bd20366a82">operator=</a> (const optional&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memitem:a903be85207735fdef630b75ba3479402" id="r_a903be85207735fdef630b75ba3479402"><td class="memTemplParams" colspan="2">template&lt;class U&gt; <br />
requires (detail::enable_assign_from_other&lt;T, U, U&gt;)</td></tr>
<tr class="memitem:a903be85207735fdef630b75ba3479402 template"><td class="memItemLeft">constexpr optional&lt; T &gt; &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a903be85207735fdef630b75ba3479402">operator=</a> (optional&lt; U &gt; &amp;&amp;rhs)</td></tr>
<tr class="memitem:a818aaa2044440c7b1dbf8c5f42fd4865" id="r_a818aaa2044440c7b1dbf8c5f42fd4865"><td class="memTemplParams" colspan="2">template&lt;class F&gt; <br />
requires (std::invocable&lt;F&gt; &amp;&amp; std::copy_constructible&lt;T&gt;)</td></tr>
<tr class="memitem:a818aaa2044440c7b1dbf8c5f42fd4865 template"><td class="memItemLeft">constexpr optional&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a818aaa2044440c7b1dbf8c5f42fd4865">or_else</a> (F &amp;&amp;f) const &amp;</td></tr>
<tr class="memdesc:a818aaa2044440c7b1dbf8c5f42fd4865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an optional containing the contained value if it has one, or the result of calling <code class="param">`f`</code> if it does not.  <br /></td></tr>
<tr class="memitem:a70335aca16ff2088b1cab646bb0e2318" id="r_a70335aca16ff2088b1cab646bb0e2318"><td class="memTemplParams" colspan="2">template&lt;class F&gt; <br />
requires (std::invocable&lt;F&gt; &amp;&amp; std::move_constructible&lt;T&gt;)</td></tr>
<tr class="memitem:a70335aca16ff2088b1cab646bb0e2318 template"><td class="memItemLeft">constexpr optional&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a70335aca16ff2088b1cab646bb0e2318">or_else</a> (F &amp;&amp;f) &amp;&amp;</td></tr>
<tr class="memdesc:a70335aca16ff2088b1cab646bb0e2318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an optional containing the contained value if it has one, or the result of calling <code class="param">`f`</code> if it does not.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class beman::optional::optional&lt; T &gt;</div><p>Optional Objects. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="base_derived_cast_8cpp-example.html#_a0">base_derived_cast.cpp</a>, <a class="el" href="concept_checks_8cpp-example.html#_a0">concept_checks.cpp</a>, <a class="el" href="optional_ref_8cpp-example.html#_a1">optional_ref.cpp</a>, <a class="el" href="pythagorean_triples_8cpp-example.html#_a0">pythagorean_triples.cpp</a>, <a class="el" href="range_loop_8cpp-example.html#_a0">range_loop.cpp</a>, <a class="el" href="sample_8cpp-example.html#_a0">sample.cpp</a>, and <a class="el" href="std_vs_beman_8cpp-example.html#_a0">std_vs_beman.cpp</a>.</dd>
</dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="ac098cfd77cfd048a49d2d535704b4344" name="ac098cfd77cfd048a49d2d535704b4344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac098cfd77cfd048a49d2d535704b4344">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">detail::contiguous_iterator&lt;<span class="keyword">const</span> T,</div>
<div class="line">                                                      optional&gt;</div>
</div><!-- fragment -->
<p>Type alias for the const iterator type of the optional. </p>
<p>Since P3168R2: Give std::optional Range Support. </p>

</div>
</div>
<a id="af18ae5651fcc0ed78f0cab2a85ad8a07" name="af18ae5651fcc0ed78f0cab2a85ad8a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18ae5651fcc0ed78f0cab2a85ad8a07">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">detail::contiguous_iterator&lt;T,</div>
<div class="line">                                                optional&gt;</div>
</div><!-- fragment -->
<p>Type alias for the iterator type of the optional. </p>
<p>Since P3168R2: Give std::optional Range Support. </p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a57d14f0bedc03b049d37dcd96aa7f3fe" name="a57d14f0bedc03b049d37dcd96aa7f3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d14f0bedc03b049d37dcd96aa7f3fe">&#9670;&#160;</a></span>optional() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::optional </td>
          <td>(</td>
          <td class="paramtype">const optional&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs the value from <code class="param">rhs</code> if it has one. </p>
<p>Defaulted if T is trivially copy constructible. </p>

</div>
</div>
<a id="a8c1214300c7a79c170c716bb22824b2c" name="a8c1214300c7a79c170c716bb22824b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1214300c7a79c170c716bb22824b2c">&#9670;&#160;</a></span>optional() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::optional </td>
          <td>(</td>
          <td class="paramtype">optional&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructs the value from <code class="param">rhs</code> if it has one. </p>
<p>Defaulted if T is trivially move constructible. </p>

</div>
</div>
<a id="af27e6b6d80787e82db114a3be987512f" name="af27e6b6d80787e82db114a3be987512f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27e6b6d80787e82db114a3be987512f">&#9670;&#160;</a></span>optional() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; <br />
requires std::is_constructible_v&lt;T, Args...&gt;</div>
<div class="memtemplate">
template&lt;class... Args&gt; <br />
requires std::is_constructible_v&lt;T, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbeman_1_1optional_1_1in__place__t.html">in_place_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the value in-place using the given arguments. </p>
<p>Constructs the contained value in-place using the given arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments to use for in-place construction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af75c591a86a8ee7d0185e67189234039" name="af75c591a86a8ee7d0185e67189234039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75c591a86a8ee7d0185e67189234039">&#9670;&#160;</a></span>optional() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; <br />
requires std::is_constructible_v&lt;T, std::initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</div>
<div class="memtemplate">
template&lt;class U, class... Args&gt; <br />
requires std::is_constructible_v&lt;T, std::initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbeman_1_1optional_1_1in__place__t.html">in_place_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; U &gt;</td>          <td class="paramname"><span class="paramname"><em>il</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the value in-place using the given arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to use for in-place construction. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to use for in-place construction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a4e2cee231a67ca48f82715cdd334bf94" name="a4e2cee231a67ca48f82715cdd334bf94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2cee231a67ca48f82715cdd334bf94">&#9670;&#160;</a></span>and_then() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::and_then </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a function to the contained value if there is one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the invocable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The invocable to apply to the contained value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto</dd></dl>
<p>The return type is the same as <span class="tt">std::invoke_result_t&lt;F, T&amp;&gt;</span>, but wrapped in an optional. The function <code class="param">f</code> must return an optional type. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="optional_ref_8cpp-example.html#a0">optional_ref.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a09d36e0c91acecd4dd1983c8159f8c85" name="a09d36e0c91acecd4dd1983c8159f8c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d36e0c91acecd4dd1983c8159f8c85">&#9670;&#160;</a></span>and_then() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::and_then </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a function to the contained value if there is one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the invocable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The invocable to apply to the contained value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto</dd></dl>
<p>The return type is the same as <span class="tt">std::invoke_result_t&lt;F, T&amp;&gt;</span>, but wrapped in an optional. The function <code class="param">f</code> must return an optional type. </p>

</div>
</div>
<a id="ab90dcd5e2580af7c3e885428a939cfe4" name="ab90dcd5e2580af7c3e885428a939cfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90dcd5e2580af7c3e885428a939cfe4">&#9670;&#160;</a></span>and_then() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::and_then </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a function to the contained value if there is one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the invocable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The invocable to apply to the contained value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto</dd></dl>
<p>The return type is the same as <span class="tt">std::invoke_result_t&lt;F, T&amp;&gt;</span>, but wrapped in an optional. The function <code class="param">f</code> must return an optional type. </p>

</div>
</div>
<a id="a1f777fa3e547b9e56ad0633bc8714133" name="a1f777fa3e547b9e56ad0633bc8714133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f777fa3e547b9e56ad0633bc8714133">&#9670;&#160;</a></span>and_then() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::and_then </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a function to the contained value if there is one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the invocable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The invocable to apply to the contained value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto</dd></dl>
<p>The return type is the same as <span class="tt">std::invoke_result_t&lt;F, T&amp;&gt;</span>, but wrapped in an optional. The function <code class="param">f</code> must return an optional type. </p>

</div>
</div>
<a id="a07d0a37da89665a15c7910afbf8e199c" name="a07d0a37da89665a15c7910afbf8e199c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d0a37da89665a15c7910afbf8e199c">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; T &gt;<a class="el" href="#ac098cfd77cfd048a49d2d535704b4344">::const_iterator</a> <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the beginning of the optional. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="#ac098cfd77cfd048a49d2d535704b4344" title="Type alias for the const iterator type of the optional.">const_iterator</a> </dd></dl>

</div>
</div>
<a id="a8b80251c803ff7de9e28e4e3cf16a6f2" name="a8b80251c803ff7de9e28e4e3cf16a6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b80251c803ff7de9e28e4e3cf16a6f2">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; T &gt;<a class="el" href="#af18ae5651fcc0ed78f0cab2a85ad8a07">::iterator</a> <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the optional. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

</div>
</div>
<a id="ac20ea14c0765679cb2bf4c74b5c82bd5" name="ac20ea14c0765679cb2bf4c74b5c82bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20ea14c0765679cb2bf4c74b5c82bd5">&#9670;&#160;</a></span>emplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the value in-place, destroying the current one if there. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The argument list to use in emplacement construction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp;</dd></dl>
<p>Constructs the value in-place, destroying the current one if there is one. </p>

</div>
</div>
<a id="a3057f723870a4c2c67ed0be186a96481" name="a3057f723870a4c2c67ed0be186a96481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3057f723870a4c2c67ed0be186a96481">&#9670;&#160;</a></span>emplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U, class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;</td>          <td class="paramname"><span class="paramname"><em>il</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the value in-place using the given arguments, destroying the current one if there. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td></td></tr>
    <tr><td class="paramname">Args</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The initializer list to use in emplacement construction. </td></tr>
    <tr><td class="paramname">args</td><td>The argument list to use in emplacement construction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; </dd></dl>

</div>
</div>
<a id="ab6746328dd0c1ff4e363f7a5e89e910e" name="ab6746328dd0c1ff4e363f7a5e89e910e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6746328dd0c1ff4e363f7a5e89e910e">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; T &gt;<a class="el" href="#ac098cfd77cfd048a49d2d535704b4344">::const_iterator</a> <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the end of the optional. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="#ac098cfd77cfd048a49d2d535704b4344" title="Type alias for the const iterator type of the optional.">const_iterator</a> </dd></dl>

</div>
</div>
<a id="a59208fb74a69302b36ab42fa4d61ce74" name="a59208fb74a69302b36ab42fa4d61ce74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59208fb74a69302b36ab42fa4d61ce74">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; T &gt;<a class="el" href="#af18ae5651fcc0ed78f0cab2a85ad8a07">::iterator</a> <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end of the optional. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>

</div>
</div>
<a id="ab2d2eb0bf74ff29513838d9641479199" name="ab2d2eb0bf74ff29513838d9641479199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d2eb0bf74ff29513838d9641479199">&#9670;&#160;</a></span>explicit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U&gt; <br />
requires (detail::enable_from_other&lt;T, U, const U&amp;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::explicit </td>
          <td>(</td>
          <td class="paramtype">!std::is_convertible_v&lt; U, T &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the value from <code class="param">rhs</code> if it has one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4146fd29dd405c306bb8a30fba3a989" name="ac4146fd29dd405c306bb8a30fba3a989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4146fd29dd405c306bb8a30fba3a989">&#9670;&#160;</a></span>explicit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U = T&gt; <br />
requires detail::enable_forward_value&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::explicit </td>
          <td>(</td>
          <td class="paramtype">!std::is_convertible_v&lt; U, T &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the value from <code class="param">u</code>, forwarding it if necessary. </p>
<p>If <code class="param">u</code> is convertible to <code class="param">T</code>, this is an explicit constructor. </p>

</div>
</div>
<a id="a30353c697fc17e7b421cde25cab03d24" name="a30353c697fc17e7b421cde25cab03d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30353c697fc17e7b421cde25cab03d24">&#9670;&#160;</a></span>has_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::has_value </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not the optional has a value. </p>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="std_vs_beman_8cpp-example.html#a1">std_vs_beman.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2b3f8f20f9fc411b656ebcc9c2a45fbc" name="a2b3f8f20f9fc411b656ebcc9c2a45fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3f8f20f9fc411b656ebcc9c2a45fbc">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the optional to a boolean indicating whether it has a value. </p>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="af6278cfdf226813b44e48bcca9e9c160" name="af6278cfdf226813b44e48bcca9e9c160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6278cfdf226813b44e48bcca9e9c160">&#9670;&#160;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the contained value. </p>
<p>Returns the contained value.</p>
<dl class="section return"><dt>Returns</dt><dd>T&amp; </dd></dl>

</div>
</div>
<a id="aa8cf9e9651cd496ce32f7b7bcb810874" name="aa8cf9e9651cd496ce32f7b7bcb810874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cf9e9651cd496ce32f7b7bcb810874">&#9670;&#160;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp;&amp; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the contained value. </p>
<dl class="section return"><dt>Returns</dt><dd>T&amp;&amp; </dd></dl>

</div>
</div>
<a id="ae2066b2ca9b88bda6f8a31f75c334b00" name="ae2066b2ca9b88bda6f8a31f75c334b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2066b2ca9b88bda6f8a31f75c334b00">&#9670;&#160;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the contained value. </p>
<dl class="section return"><dt>Returns</dt><dd>const T&amp; </dd></dl>

</div>
</div>
<a id="a11514681edbb160cf2efc43ef55c5528" name="a11514681edbb160cf2efc43ef55c5528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11514681edbb160cf2efc43ef55c5528">&#9670;&#160;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the contained value. </p>
<dl class="section return"><dt>Returns</dt><dd>T* </dd></dl>

</div>
</div>
<a id="acc77319af3acf2481397213952ff17d3" name="acc77319af3acf2481397213952ff17d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc77319af3acf2481397213952ff17d3">&#9670;&#160;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional &amp; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const optional&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assigns the value from <code class="param">rhs</code> if it has one. </p>
<dl class="section return"><dt>Returns</dt><dd>optional&amp; </dd></dl>

</div>
</div>
<a id="a49295670a71a3219a5d308bd20366a82" name="a49295670a71a3219a5d308bd20366a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49295670a71a3219a5d308bd20366a82">&#9670;&#160;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U&gt; <br />
requires (detail::enable_assign_from_other&lt;T, U, const U&amp;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; T &gt; &amp; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const optional&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converting copy assignment operator.</p>
<p>Copies the value from <span class="tt">rhs</span> if there is one. Otherwise resets the contained value in <span class="tt">*this</span>. </p>

</div>
</div>
<a id="a903be85207735fdef630b75ba3479402" name="a903be85207735fdef630b75ba3479402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903be85207735fdef630b75ba3479402">&#9670;&#160;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U&gt; <br />
requires (detail::enable_assign_from_other&lt;T, U, U&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; T &gt; &amp; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">optional&lt; U &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converting move assignment operator.</p>
<p>Moves the value from <span class="tt">rhs</span> if there is one. Otherwise resets the contained value in <span class="tt">*this</span>. </p>

</div>
</div>
<a id="a2f66e32d69388df3d7e3acb601058776" name="a2f66e32d69388df3d7e3acb601058776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f66e32d69388df3d7e3acb601058776">&#9670;&#160;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U&gt; <br />
requires detail::enable_assign_forward&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; T &gt; &amp; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assigns the contained value from <span class="tt">u</span>, destroying the old value if there was one. </p>

</div>
</div>
<a id="adb7fe1c0bcc29a9c97c3410c9537ff70" name="adb7fe1c0bcc29a9c97c3410c9537ff70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7fe1c0bcc29a9c97c3410c9537ff70">&#9670;&#160;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U = T&gt; <br />
requires detail::enable_assign_forward&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional &amp; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the contained value from <code class="param">u</code>, destroying the old value if there. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the value to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The value to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional&amp; </dd></dl>

</div>
</div>
<a id="a70335aca16ff2088b1cab646bb0e2318" name="a70335aca16ff2088b1cab646bb0e2318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70335aca16ff2088b1cab646bb0e2318">&#9670;&#160;</a></span>or_else() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; <br />
requires (std::invocable&lt;F&gt; &amp;&amp; std::move_constructible&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; T &gt; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::or_else </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an optional containing the contained value if it has one, or the result of calling <code class="param">`f`</code> if it does not. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;T&gt; </dd></dl>

</div>
</div>
<a id="abbd48b7ce4f8c980bc92a40f0f886449" name="abbd48b7ce4f8c980bc92a40f0f886449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd48b7ce4f8c980bc92a40f0f886449">&#9670;&#160;</a></span>or_else() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; <br />
requires (std::invocable&lt;F&gt; &amp;&amp; std::move_constructible&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::or_else </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an optional containing the contained value if it has one, or the result of calling <code class="param">f</code> if it does not. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>An invocable type returning an optional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The invocable to call if the optional is disengaged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto </dd></dl>

</div>
</div>
<a id="a818aaa2044440c7b1dbf8c5f42fd4865" name="a818aaa2044440c7b1dbf8c5f42fd4865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818aaa2044440c7b1dbf8c5f42fd4865">&#9670;&#160;</a></span>or_else() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; <br />
requires (std::invocable&lt;F&gt; &amp;&amp; std::copy_constructible&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional&lt; T &gt; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::or_else </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an optional containing the contained value if it has one, or the result of calling <code class="param">`f`</code> if it does not. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;T&gt; </dd></dl>

</div>
</div>
<a id="a7f407bdbf5ebf9cc166b0d7659a4001c" name="a7f407bdbf5ebf9cc166b0d7659a4001c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f407bdbf5ebf9cc166b0d7659a4001c">&#9670;&#160;</a></span>or_else() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; <br />
requires (std::invocable&lt;F&gt; &amp;&amp; std::copy_constructible&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optional <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::or_else </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an optional containing the contained value if it has one, or the result of applying <code class="param">f</code> to the optional if it does not. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>An invocable type returning an optional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The invocable to call if the optional is disengaged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional </dd></dl>

</div>
</div>
<a id="a3aa22eefcb8377a2ff2c3eaba050cc23" name="a3aa22eefcb8377a2ff2c3eaba050cc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa22eefcb8377a2ff2c3eaba050cc23">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">optional&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps this optional with the other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The optional to swap with.</td></tr>
  </table>
  </dd>
</dl>
<p>Swaps this optional with the other.</p>
<p>If neither optionals have a value, nothing happens. If both have a value, the values are swapped. If one has a value, it is moved to the other and the movee is left valueless. </p>

</div>
</div>
<a id="ab409242d8b0b3ed4fda5d4c66e3e2db6" name="ab409242d8b0b3ed4fda5d4c66e3e2db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab409242d8b0b3ed4fda5d4c66e3e2db6">&#9670;&#160;</a></span>transform() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an optional containing the result of applying <code class="param">f</code> to the contained value, or an empty optional if there is no contained value. </p>
<p>Carries out some operation on the contained object if there is one.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>An invocable to apply to the contained value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optional </dd></dl>
<p>References now allowed</p>

</div>
</div>
<a id="a6989e2a3dc4e30dd38a1a8d689616f05" name="a6989e2a3dc4e30dd38a1a8d689616f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6989e2a3dc4e30dd38a1a8d689616f05">&#9670;&#160;</a></span>transform() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an optional containing the result of applying <code class="param">f</code> to the contained value, or an empty optional if there is no contained value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>An invocable to apply to the contained value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto </dd></dl>
<p>References now allowed</p>

</div>
</div>
<a id="ae7aae84b3e296d65d93b132bca8e79dc" name="ae7aae84b3e296d65d93b132bca8e79dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7aae84b3e296d65d93b132bca8e79dc">&#9670;&#160;</a></span>transform() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an optional containing the result of applying <code class="param">f</code> to the contained value, or an empty optional if there is no contained value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>An invocable to apply to the contained value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto </dd></dl>
<p>References now allowed</p>

</div>
</div>
<a id="ae686bd0b6e17116c73a1c2aa2cae116d" name="ae686bd0b6e17116c73a1c2aa2cae116d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae686bd0b6e17116c73a1c2aa2cae116d">&#9670;&#160;</a></span>transform() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an optional containing the result of applying <code class="param">f</code> to the contained value, or an empty optional if there is no contained value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>An invocable to apply to the contained value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto </dd></dl>
<p>References now allowed</p>

</div>
</div>
<a id="a403cec6d7cc62ed49dc6c1a932da6de3" name="a403cec6d7cc62ed49dc6c1a932da6de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403cec6d7cc62ed49dc6c1a932da6de3">&#9670;&#160;</a></span>value() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the contained value. </p>
<dl class="section return"><dt>Returns</dt><dd>T&amp;</dd></dl>
<p>Returns the contained value if there is one, otherwise throws <a class="el" href="classbeman_1_1optional_1_1bad__optional__access.html" title="Exception thrown when trying to access the value of an empty optional.">bad_optional_access</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="std_vs_beman_8cpp-example.html#a2">std_vs_beman.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad03f9b933291169eeba5e53cdfd50867" name="ad03f9b933291169eeba5e53cdfd50867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03f9b933291169eeba5e53cdfd50867">&#9670;&#160;</a></span>value() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp;&amp; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the contained value. </p>
<dl class="section return"><dt>Returns</dt><dd>T&amp;&amp; </dd></dl>

</div>
</div>
<a id="a78ed5dfa0c06503c1a682e6790727498" name="a78ed5dfa0c06503c1a682e6790727498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ed5dfa0c06503c1a682e6790727498">&#9670;&#160;</a></span>value() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the contained value. </p>
<dl class="section return"><dt>Returns</dt><dd>const T&amp; </dd></dl>

</div>
</div>
<a id="ac096c3c3ac924809a2a9d24aa88b30c1" name="ac096c3c3ac924809a2a9d24aa88b30c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac096c3c3ac924809a2a9d24aa88b30c1">&#9670;&#160;</a></span>value_or() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_cv_t&lt; T &gt; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::value_or </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the contained value if there is one, otherwise returns <span class="tt">u</span>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternate value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The value to return in the empty case </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T </dd></dl>

</div>
</div>
<a id="a1a4d7b910633a73a4aecaac930684aef" name="a1a4d7b910633a73a4aecaac930684aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4d7b910633a73a4aecaac930684aef">&#9670;&#160;</a></span>value_or() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_cv_t&lt; T &gt; <a class="el" href="classbeman_1_1optional_1_1optional.html">beman::optional::optional</a>&lt; T &gt;::value_or </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the contained value if there is one, otherwise returns <span class="tt">u</span>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternate value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The value to return in the empty case </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/beman/optional/<a class="el" href="optional_8hpp_source.html">optional.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>beman</b></li><li class="navelem"><b>optional</b></li><li class="navelem"><a href="classbeman_1_1optional_1_1optional.html">optional</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
